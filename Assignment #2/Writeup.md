Process Scheduling Algorithms                                                  
CS 149: Operating Systems
Assignment #2                                                                                      
Team: Theta 1
Luke Sieben, Dennis Hsu, David-Eric Thorpe, Nathan Kong
       Process scheduling is used in computing to decide which process should run and in what order. In this project, six scheduling algorithms were tested and evaluated.  The algorithms included first-come first-serve (FCFS) [non-preemptive], shortest job first (SJF) [non-preemptive], shortest remaining time SRT [preemptive], round robin (RR) [preemptive], highest priority first (HPF) [nonpreemptive and preemptive]. 
       Each algorithm was tested five times with a minimum of 100 quanta under a load of 30 random Processes. The algorithms were evaluated for average turnaround time, average waiting time, average response time, and throughput. Randomly generated process data was created and sent to each algorithm. The process data included an arrival time between 0 to 99 as a float value, an expected total run time between 0.1 to 10 as a float value, and a priority number between 1 to 4 as an integer value. For the priority number 1 was labeled as the highest priority while 4 was labeled as the lowest priority.
       The FCFS algorithm runs processes in the order they arrive in.  Once a process is started, it is run to completion. Only 1 process will run past the 100 quanta cutoff. The SJF algorithm runs the processes with the shortest burst time of those processes that have been submitted.  Once a process is started, it is run to completion. Upon completion the next shortest job of the submitted jobs is then run. Only 1 process will run past the 100 quanta cutoff. The SRT algorithm runs processes with the shortest burst time. At the beginning of each quantum, all available processes are evaluated for the shortest burst time. The process with the shortest burst time, is then run until a new process with a shorter burst time becomes available. Many processes may run past the 100 quanta cutoff but will likely be short. The RR algorithm runs each available process in the order submitted for one quantum.  If the process still requires additional time, the CPU pauses the process until all other available processes have taken its turn to run one quantum.  For a sufficiently small sample size most processes will continue their run after the 100 quanta cutoff. The HPF [non-preemptive] algorithm runs processes with the highest priority first. Once a process is started, it is run to completion. This algorithm creates the issue of starvation for lower priority processes.  To solve the issue aging was incorporated into this algorithm. Only 1 process will run past the 100 quanta cutoff. The HPF [preemptive] algorithm runs processes with the highest priority first. At the beginning of each quantum, all available processes are evaluated for the highest priority. The process with the highest priority is then run until a new process with a higher priority becomes available. Aging was incorporated into this algorithm to prevent starvation. Several processes may run after the 100 quanta cut off if they have previously been preempted.
       The algorithms with the best throughput was SJF and SRT. These algorithms run the processes with the least time remaining, which will fit as many processes within the 100 quanta time slice as possible. The algorithm with the worst throughput is RR. This algorithm starts every job possible.  As the queue increases the wait time per process increases, therefore preventing processes from finishing within the 100 quanta time slice.
       The algorithms with the best average wait times are SRT and SJF. These algorithms have similar wait times due to their nature. Processes with long run times are held in the queue while the shortest processes essentially have no wait time. The algorithm with the worst average wait time is RR. As processes become active and gets added to the queue, the waiting time for each process in the queue increases. In addition, RR starts the most processes under 100 quanta and uses more total quanta than any other algorithm.
       The algorithms with the best average turnaround times are SRT and SJF. These algorithms take the “low hanging fruit,” or those processes that are sure to complete quickly. Larger processes though may be preempted until starvation. The algorithm with the worst average turnaround time is RR because the minimum amount of work performed would take as long to complete as the number of other processes queued. This ensures that all processes are run, but not in a timely manner.
       The algorithm with the best average response times for its processes was SRT. SJF closely followed but proved to be approximately 1.5 quanta more according to the raw data. Since SRT is preemptive, when a new process that enter the queue and has the shortest run time that new process instantly begins running. The algorithms with the worst average response times are HPF, HPFP, and FCFS. These algorithms prioritize processes in methods which ignore and can starve processes.
       Despite all these statistics certain algorithms are easier to implement, such as FCFS. Implementing easier algorithms incorporates less overhead required for management and creates a more attractive scheduler in certain conditions. Other algorithms may be better suited for other applications. RR performs poorly is most metrics except that it is sure to serve all processes. Eventually. Other algorithms strengths focus on certain statistics. HPF focuses on running algorithms based on importance, so less important processes are left to run at a later time. This can be made less harsh toward low priority process by incorporated aging which can promote old processes to higher priorities.  Depending on the situation, the choice of the best scheduler for getting the best results may differ.
